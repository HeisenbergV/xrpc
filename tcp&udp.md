# tcp&udp

## TCP/IP 模型
![网络模型](网络模型.png)

## 运输层
与应用层的关系：应用层将数据发送给运输层，运输层将其进行分段处理，每段数据加入头协议，然后分组发出去
与网络层的关系：分组的数据发给网络层，网络层将数据真正的发给链路层，然后从物理链路发到指定服务的进程中去

举例：
北京一个资产阶级家庭： 小明家庭
天津一个资产阶级家庭： 小红家庭
小明写了封信，交给管家，管家将信给邮政局，邮政局收到后，寄到天津小红家，管家将信给小红

小明家庭的任意成员写信->小明家的管家->邮局->小红家的管家->小红

应用层：信的内容
进程：小明
主机：小明的家庭 和 小红的家庭
运输层：管家
网络层：邮局

## 简单介绍udp tcp
tcp将应用层数据，分段处理 称为 报文段（seg-ment)
upd将应用层数据，分段处理 称为 数据报

IP层 网际协议，为主机之间提供逻辑通信，尽力而为的交付服务（best-effort delivery service)
所以不保证数据不会丢失，报文段的顺序，并且附带了一个唯一表示的地址也就是ip地址来进行主机之间的确认

udp和tcp 的基本责任是对两个端系统间的进程进行交付服务。
主机间交付扩展到进程间交付被称之为 运输层的多路复用，与多路分解

udp和ip层一样 无法提供可靠传输

tcp通过流量控制，序号，确认，定时器，达到可靠传输
tcp通过滑动窗口达到拥塞控制，为整个互联网提供平等的带宽

## 多路复用，多路分解
![运输层](运输层.png)

一个主机有多个进程，每个进程为了通信会建立一个套接字（socket)，而一个主机只有一个运输层，所以多个socket将数据传输给运输层，运输层将这些数据进行封装上首部信息（为了以后的分解）从而生成报文段。然后将报文段传递给网络层，这个过程就是多路复用。

当主机收到其他主机的数据，运输层根据报文段的首部信息找到指定的socket。这个过程就是多路分解

举例：依旧是上面的例子，当管家收到信件后，需要依靠信件上的名字，给指定的成员（小明，爸爸，妈妈）。
这个管家的操作就是多路分解。当成员（小明，爸爸，妈妈）写了信给管家，管家进行整理然后发送给邮政局，这个管家的操作就是多路复用

通过上述描述，运输层的多路复用的要求是：
1. 每一个套接字要有唯一的标识，否则运输层无法分辨该将数据给谁
2. 每个报文段要有特殊的字段来标识，要交付给哪个套接字（也就是端口 port）

|-----------------|
| 源端口 | 目的端口 |
|-----------------|
|   其他首部字段    |
|-----------------|
|    应用数据      |
|-----------------|

### udp的多路复用 多路分解
一个udp套接字使用一个二元组来全面标识，该二元组包含：一个目的IP地址和一个目的端口号。
所以多个客户端连接到同一个进程的同一个套接字

### tcp的多路复用 多路分解
一个tcp套接字使用一个四元组来全面标识，该四元组包含：一个目的IP地址和一个目的端口，一个源地址和一个源端口。所以每一个客户端连接都会维护一个套接字，一个tcp服务会维护多个套接字管理多个客户端连接

![多路复用](多路复用.jpg)

## udp
udp其实就是做了点 多路复用/多路分解，除此之外没任何额外功能，和网络层唯一区别就是这点功能。由[RFC 768](https://tools.ietf.org/html/rfc768)定义的UDP只做运输层能够做的最少工作。

udp将数据附加上多路复用/分解服务的源和目的端口字段，以及其他两个小字段后，将报文段交给网络层。网络层将报文段封装到一个IP数据报中，然后尽力而为交给目的主机，到达后udp进行多路分解交付给指定的进程，在发送数据前并没有与接收方进行握手确认。所以udp被称为 `无连接的`

### udp优点
- 关于何时，发送什么数据的应用层控制更为精细：tcp为了可靠传输不管交付用多长时间，udp不提供不必要的额外功能所以更快
- 无需建立连接：意味着不会有建立连接的延迟
- 无连接状态：tcp为了实现可靠传输会维护连接状态，udp没有，因此一般情况udp的能支持更多的用户量
- 分组首部开销小： tcp报文段20个字节的首部开销，udp8字节

udp是可以进行可靠传输的，那就是在应用层进行可靠传输的逻辑处理。一旦这样是不是udp就成了最好的解决方案了？ 相当于tcp和udp优点的结合，而抛弃了tcp的拥塞控制。
答案是错误的，虽然看起来是可行的，但对于整个互联网是造成了压力，间接的提高了udp的丢包率。

举例：如果把拥塞控制比喻成城市的红绿灯，udp汽车不管红绿灯，在车少的时候当然非常快速，很快就能达到目的。但当汽车很多，所有人都不遵守交通规则，那么反而不如tcp汽车遵守交通规则来的更快。

### udp报文段
首部四个字段，都是2字节，一共8字节
+--------+--------+--------+--------+
|     Source      |   Destination   |
|      Port       |      Port       |
+--------+--------+--------+--------+
|                 |                 |
|     Length      |    Checksum     |
+--------+--------+--------+--------+
|                                   |
|          data                     | 
+-----------------------------------

1. 源端口：源端口号。在需要对方回信时选用。不需要时可用全0
2. 目的端口：目的端口号。这在终点交付报文时必须要使用到
3. 长度： UDP用户数据报的长度，其最小值是8（仅有首部）
4. 校验和：检测UDP用户数据报在传输中是否有错。有错就丢弃

### udp校验和计算
校验和提供了差错检测功能。也就是说，报文段从源到达目的地的过程中，判断比特是否发生了改变（链路中的噪声干扰或者路由器的问题）。发送方的udp对报文段中的所有16比特字的和进行反码运算，求和时遇到溢出都会被回卷。得到的结果放到校验和字段`checksum`

举例：
字段            十进制             二进制
源端口            63549          1111100000111101  
目的端口          12345           11000000111001
数据长度            17              10001
校验和          

发送前计算校验和：
1. 源端口+目的端口+数据长度 = 1111100000111101+0011000000111001+10001 = 10010100010000111
2. 16位溢出，回卷，抛弃首位：10010100010000111 ==> 0010100010000111
3. 反码：0010100010000111==>1101011101111000
4. 校验和 = 1101011101111000

接受后检验校验和：
1. 源端口+目的端口+数据长度 = 1111100000111101+0011000000111001+10001 = 10010100010000111
2. 16位溢出，回卷，抛弃首位：10010100010000111 ==> 0010100010000111
3. 结果与校验和相加：0010100010000111（计算结果） + 1101011101111000(校验和)
4. 如果结果不为 1111111111111111（16个1） 则一定有问题；如果结果为16个1，则表示可能没错（单比特翻转）

结论：校验和功能，不只是在传输层，在网络层，链路层也会做校验，每一层都会做自己首部的校验处理。虽然如此，依旧不能保证最终的无误。传输层的做的最后校验也会有几率检查不出来（单比特翻转）
概率虽然低，但依旧有可能。这时需要依靠应用层做最终的校验

## 可靠传输
可靠传输协议（reliable data transfer protocol)是使用一个个的技术点组合达到最终的可靠传输。
所以我们一个个了解，最终迭代出一个可靠传输的最终版本，当了解了这些可靠传输的每一个原理，就能在应用层用udp实现可靠传输了。

### 经完全可靠信道的可靠数据传输 rdt1.0





## 关于数据包的最大值确定
 UDP和TCP协议利用端口号实现多项应用同时发送和接收数据。数据通过源端口发送出去，通过目标端口接收。有的网络应用只能使用预留或注册的静态端口；而另外一些网络应用则可以使用未被注册的动态端口。因为UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535。动态端口的范围是从1024到65535。　　

        MTU最大传输单元，这个最大传输单元实际上和链路层协议有着密切的关系，EthernetII帧的结构DMAC+SMAC+Type+Data+CRC由于以太网传输电气方面的限制，每个以太网帧都有最小的大小64Bytes最大不能超过1518Bytes，对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧。

 

        由于以太网EthernetII最大的数据帧是1518Bytes这样，刨去以太网帧的帧头（DMAC目的MAC地址48bits=6Bytes+SMAC源MAC地址48bits=6Bytes+Type域2Bytes）14Bytes和帧尾CRC校验部分4Bytes那么剩下承载上层协议的地方也就是Data域最大就只能有1500Bytes这个值我们就把它称之为MTU。

　　链路层帧的大小  1500(不包括帧头、帧尾)

　　UDP 包的大小就应该是 1500 - IP头(20) - UDP头(8) = 1472(Bytes)
　　TCP 包的大小就应该是 1500 - IP头(20) - TCP头(20) = 1460 (Bytes)