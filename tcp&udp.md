# tcp&udp

## TCP/IP 模型
![网络模型](网络模型.png)

## 运输层
与应用层的关系：应用层将数据发送给运输层，运输层将其进行分段处理，每段数据加入头协议，然后分组发出去
与网络层的关系：分组的数据发给网络层，网络层将数据真正的发给链路层，然后从物理链路发到指定服务的进程中去

举例：
北京一个资产阶级家庭： 小明家庭
天津一个资产阶级家庭： 小红家庭
小明写了封信，交给管家，管家将信给邮政局，邮政局收到后，寄到天津小红家，管家将信给小红

小明家庭的任意成员写信->小明家的管家->邮局->小红家的管家->小红

应用层：信的内容
进程：小明
主机：小明的家庭 和 小红的家庭
运输层：管家
网络层：邮局

## 简单介绍udp tcp
tcp将应用层数据，分段处理 称为 报文段（seg-ment)
upd将应用层数据，分段处理 称为 数据报

IP层 网际协议，为主机之间提供逻辑通信，尽力而为的交付服务（best-effort delivery service)
所以不保证数据不会丢失，报文段的顺序，并且附带了一个唯一表示的地址也就是ip地址来进行主机之间的确认

udp和tcp 的基本责任是对两个端系统间的进程进行交付服务。
主机间交付扩展到进程间交付被称之为 运输层的多路复用，与多路分解

udp和ip层一样 无法提供可靠传输

tcp通过流量控制，序号，确认，定时器，达到可靠传输
tcp通过滑动窗口达到拥塞控制，为整个互联网提供平等的带宽

## 多路复用，多路分解
![运输层](运输层.png)

一个主机有多个进程，每个进程为了通信会建立一个套接字（socket)，而一个主机只有一个运输层，所以多个socket将数据传输给运输层，运输层将这些数据进行封装上首部信息（为了以后的分解）从而生成报文段。然后将报文段传递给网络层，这个过程就是多路复用。

当主机收到其他主机的数据，运输层根据报文段的首部信息找到指定的socket。这个过程就是多路分解

举例：依旧是上面的例子，当管家收到信件后，需要依靠信件上的名字，给指定的成员（小明，爸爸，妈妈）。
这个管家的操作就是多路分解。当成员（小明，爸爸，妈妈）写了信给管家，管家进行整理然后发送给邮政局，这个管家的操作就是多路复用

通过上述描述，运输层的多路复用的要求是：
1. 每一个套接字要有唯一的标识，否则运输层无法分辨该将数据给谁
2. 每个报文段要有特殊的字段来标识，要交付给哪个套接字（也就是端口 port）

|-----------------|
| 源端口 | 目的端口 |
|-----------------|
|   其他首部字段    |
|-----------------|
|    应用数据      |
|-----------------|

### udp的多路复用 多路分解
一个udp套接字使用一个二元组来全面标识，该二元组包含：一个目的IP地址和一个目的端口号。
所以多个客户端连接到同一个进程的同一个套接字

### tcp的多路复用 多路分解
一个tcp套接字使用一个四元组来全面标识，该四元组包含：一个目的IP地址和一个目的端口，一个源地址和一个源端口。所以每一个客户端连接都会维护一个套接字，一个tcp服务会维护多个套接字管理多个客户端连接

![多路复用](多路复用.jpg)

## udp
udp其实就是做了点 多路复用/多路分解，除此之外没任何额外功能，和网络层唯一区别就是这点功能。由[RFC 768](https://tools.ietf.org/html/rfc768)定义的UDP只做运输层能够做的最少工作。

udp将数据附加上多路复用/分解服务的源和目的端口字段，以及其他两个小字段后，将报文段交给网络层。网络层将报文段封装到一个IP数据报中，然后尽力而为交给目的主机，到达后udp进行多路分解交付给指定的进程，在发送数据前并没有与接收方进行握手确认。所以udp被称为 `无连接的`

### udp优点
- 关于何时，发送什么数据的应用层控制更为精细：tcp为了可靠传输不管交付用多长时间，udp不提供不必要的额外功能所以更快
- 无需建立连接：意味着不会有建立连接的延迟
- 无连接状态：tcp为了实现可靠传输会维护连接状态，udp没有，因此一般情况udp的能支持更多的用户量
- 分组首部开销小： tcp报文段20个字节的首部开销，udp8字节

udp是可以进行可靠传输的，那就是在应用层进行可靠传输的逻辑处理。一旦这样是不是udp就成了最好的解决方案了？ 相当于tcp和udp优点的结合，而抛弃了tcp的拥塞控制。
答案是错误的，虽然看起来是可行的，但对于整个互联网是造成了压力，间接的提高了udp的丢包率。

举例：如果把拥塞控制比喻成城市的红绿灯，udp汽车不管红绿灯，在车少的时候当然非常快速，很快就能达到目的。但当汽车很多，所有人都不遵守交通规则，那么反而不如tcp汽车遵守交通规则来的更快。

### udp报文段
首部四个字段，都是2字节，一共8字节
+--------+--------+--------+--------+
|     Source      |   Destination   |
|      Port       |      Port       |
+--------+--------+--------+--------+
|                 |                 |
|     Length      |    Checksum     |
+--------+--------+--------+--------+
|                                   |
|          data                     | 
+-----------------------------------

1. 源端口：源端口号。在需要对方回信时选用。不需要时可用全0
2. 目的端口：目的端口号。这在终点交付报文时必须要使用到
3. 长度： UDP用户数据报的长度，其最小值是8（仅有首部）
4. 校验和：检测UDP用户数据报在传输中是否有错。有错就丢弃

### udp校验和计算
校验和提供了差错检测功能。也就是说，报文段从源到达目的地的过程中，判断比特是否发生了改变（链路中的噪声干扰或者路由器的问题）。发送方的udp对报文段中的所有16比特字的和进行反码运算，求和时遇到溢出都会被回卷。得到的结果放到校验和字段`checksum`

举例：
字段            十进制             二进制
源端口            63549          1111100000111101  
目的端口          12345           11000000111001
数据长度            17              10001
校验和          

发送前计算校验和：
1. 源端口+目的端口+数据长度 = 1111100000111101+0011000000111001+10001 = 10010100010000111
2. 16位溢出，回卷，抛弃首位：10010100010000111 ==> 0010100010000111
3. 反码：0010100010000111==>1101011101111000
4. 校验和 = 1101011101111000

接受后检验校验和：
1. 源端口+目的端口+数据长度 = 1111100000111101+0011000000111001+10001 = 10010100010000111
2. 16位溢出，回卷，抛弃首位：10010100010000111 ==> 0010100010000111
3. 结果与校验和相加：0010100010000111（计算结果） + 1101011101111000(校验和)
4. 如果结果不为 1111111111111111（16个1） 则一定有问题；如果结果为16个1，则表示可能没错（单比特翻转）

结论：校验和功能，不只是在传输层，在网络层，链路层也会做校验，每一层都会做自己首部的校验处理。虽然如此，依旧不能保证最终的无误。传输层的做的最后校验也会有几率检查不出来（单比特翻转）
概率虽然低，但依旧有可能。这时需要依靠应用层做最终的校验

## 可靠传输
可靠传输协议（reliable data transfer protocol)是使用一个个的技术点组合达到最终的可靠传输。
所以我们一个个了解，最终迭代出一个可靠传输的最终版本，当了解了这些可靠传输的每一个原理，就能在应用层用udp实现可靠传输了。

### 经完全可靠信道的可靠数据传输 rdt1.0
当传输保证可靠，发送与接收端的收发效率也完全一致的时候模型

发送端：
rdt_send(data)

packet=make_pkt(data)
udt_send(packet)

接收端：
rdt_rcv(packet)

data=extract(packet)
deliver_data(data)

完全不必加入额外的任何操作

### 能处理比特差错信道的可靠传输 rdt2.0
在发送数据的整条链路中，比特可能受损，除此之外其他依旧假定可靠。
在和别人打电话的时候，如果听到了对方完整的话，会说一句’ok'，来证明自己听到了全部内容，且听懂了。
这个‘ok' 使用了 `肯定确认（positive acknowledgment）` 与`否定确认（negative acknowledgment）` (没听到说一句’请你再说一遍‘)
当对方收到 肯定确认就开始说下一句了， 但当收到否定确认，就要重新说一遍刚才说的话。
基于上面的重传机制的可靠传输协议称之为 `自动重传请求（AutomaticRepeat reQuest, ARQ）`协议

一共三个功能处理比特差错：
1. 差错检测：和上面的udp一样
2. 接收方反馈：收到的消息回答 肯定确认ACK 或者NAK。接收方需要向发送方发送一个报文段，其中一个字段只需要1bit，0（nak）或者1（ack）
3. 重传：接收方收到有差错的分组时，重传刚才的报文段

发送方流程：
1. rdt_send(data)
2. sndpkt=make_pkt(data, checksum)
3. udt_send(sndpkt)
4. 如果有差错 rdt_rcv(rcvpkt)&&isNAK(rcvpkt) 重传 udt_send(sndpkt)
5. 如果无差错 rdt_rcv(rcvpkt)&&isACK(rcvpkt) 继续下一个数据

接收方：
在原有基础上多了个 回复：
rdt_rcv(packet)

data=extract(packet)
deliver_data(data)

如果数据校验正确则回复ack 否则 nak

由于发送方在没有收到回复的时候要一直等着，不能发送下一个报文段，因此这样的协议 被称为 `停等（stop and wait）`协议

至此，看起来是可行了，但ack和nak 出现了比特差错怎么办？
当接收方收到由差错的ack或者nak的时候，重传当前数据即可，这种方式 叫`冗余分组 duplicate packet`。但重传了冗余的数据，接收方因为无法确认，对方是否正确收到ack或者nak，所以不确定这次数据是新的，还是冗余的。这个解决方案有个简单方法（当前所有传输协议几乎都用这个方法）就是在数据分组里添加个新字段，对数据进行编号，将发送数据分组的`序号(sequence number)`放到这个字段。
在rdt2.0 的基础上添加个新字段 做 rdt2.1 来处理上面的问题。
当前rdt2.0是停等协议，所以无需让序号递增，只需要1个bit，区分本次数据和上次数据即可。

### 能处理丢包信道的可靠传输：rdt3.0
假设发送方发送一个数据段， 发送过程中丢失了，或者接收方收到后发送ask，这个ask丢失了。都会造成发送方无法及时响应，如果发送方能等足够长的时间确定丢失，则它只需要重传即可。
但发送方要等多久合适呢？最好的时间范围应该是这样：发送方-->接收方，接收方--->发送方，这两个时间，也就是往返延迟，但确定这个时间是难以估算的。等的太久造成延迟因此实践中采取的方法是发送方明智的选择一个时间值，判断可能发生了丢包（尽管不能确定）

发送方不确定丢失的原因，但结果一样，就是重传。为了实现在指定时间判断重传。需要一个 `倒计数定时器(countdown timer)`，每次发送数据段：
- 启动一个定时器
- 处理定时器中断（正常的中断，或者超时的中断）
- 终止定时器

现在我们不怕丢失数据，不怕数据有差错了，只是当出现差错或者丢失的时候，效率很低，因为是停等协议，一个个数据处理。

### 流水线可靠传输协议 rdt3.1




## 关于数据包的最大值确定
 UDP和TCP协议利用端口号实现多项应用同时发送和接收数据。数据通过源端口发送出去，通过目标端口接收。有的网络应用只能使用预留或注册的静态端口；而另外一些网络应用则可以使用未被注册的动态端口。因为UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535。动态端口的范围是从1024到65535。　　

        MTU最大传输单元，这个最大传输单元实际上和链路层协议有着密切的关系，EthernetII帧的结构DMAC+SMAC+Type+Data+CRC由于以太网传输电气方面的限制，每个以太网帧都有最小的大小64Bytes最大不能超过1518Bytes，对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧。

 

        由于以太网EthernetII最大的数据帧是1518Bytes这样，刨去以太网帧的帧头（DMAC目的MAC地址48bits=6Bytes+SMAC源MAC地址48bits=6Bytes+Type域2Bytes）14Bytes和帧尾CRC校验部分4Bytes那么剩下承载上层协议的地方也就是Data域最大就只能有1500Bytes这个值我们就把它称之为MTU。

　　链路层帧的大小  1500(不包括帧头、帧尾)

　　UDP 包的大小就应该是 1500 - IP头(20) - UDP头(8) = 1472(Bytes)
　　TCP 包的大小就应该是 1500 - IP头(20) - TCP头(20) = 1460 (Bytes)